# -_-_pentominos_en_java_se_oracle_19c_- :. .
# ğŸ§© PentominÃ³s en Java SE + Oracle 19c.

<img width="1024" height="1024" alt="image" src="https://github.com/user-attachments/assets/d37a0030-9830-4c3a-bb4a-1773089c9749" />  

A continuaciÃ³n tienes una **soluciÃ³n profesional y coherente** para un rompecabezas de **PentominÃ³s en Java SE**, con las siguientes caracterÃ­sticas:

- ğŸ§© **ResoluciÃ³n por backtracking** (colocaciÃ³n exacta de piezas)  
- ğŸ§± **Modelo lÃ³gico** de piezas y tablero  
- ğŸ—„ï¸ **Persistencia en Oracle 19c** (guardar partidas, soluciones y mÃ©tricas)  
- ğŸ§  **DiseÃ±o limpio tipo MVC / capas**  

> âš ï¸ El enfoque es **Java SE (consola)** para claridad algorÃ­tmica.  
> La UI Swing/JavaFX puede aÃ±adirse posteriormente sin modificar la lÃ³gica.

---

## 1ï¸âƒ£ Modelo del problema

Cada **pentominÃ³** cumple:

- Contiene **5 celdas**
- Posee variantes por **rotaciÃ³n y reflexiÃ³n**
- Se coloca en un **tablero matricial** (ej. `6 x 10`)

### ğŸ¯ Objetivo

- Colocar **todas las piezas**
- Sin **solapamientos**
- Sin **espacios vacÃ­os**

---

## 2ï¸âƒ£ DiseÃ±o de capas

```text
pentominos/
â”œâ”€â”€ model/
â”‚   â”œâ”€â”€ Pentomino.java
â”‚   â”œâ”€â”€ PieceOrientation.java
â”‚   â”œâ”€â”€ Board.java
â”‚
â”œâ”€â”€ solver/
â”‚   â””â”€â”€ PentominoSolver.java
â”‚
â”œâ”€â”€ dao/
â”‚   â””â”€â”€ GameResultDAO.java
â”‚
â”œâ”€â”€ util/
â”‚   â””â”€â”€ DBConnection.java
â”‚
â””â”€â”€ Main.java
3ï¸âƒ£ Base de datos â€“ Oracle 19c
ğŸ“Œ Tabla para almacenar soluciones

CREATE TABLE PENTOMINO_GAME (
    ID_GAME        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    BOARD_ROWS     NUMBER NOT NULL,
    BOARD_COLS     NUMBER NOT NULL,
    SOLUTION_TEXT  CLOB,
    STEPS          NUMBER,
    EXEC_TIME_MS   NUMBER,
    CREATED_AT     DATE DEFAULT SYSDATE
);
4ï¸âƒ£ Modelo
ğŸ§© Pentomino.java
package model;

import java.util.List;

public class Pentomino {

    private final char name;
    private final List<boolean[][]> orientations;

    public Pentomino(char name, List<boolean[][]> orientations) {
        this.name = name;
        this.orientations = orientations;
    }

    public char getName() {
        return name;
    }

    public List<boolean[][]> getOrientations() {
        return orientations;
    }
}
ğŸ§± Board.java
package model;

public class Board {

    private final int rows;
    private final int cols;
    private final char[][] grid;

    public Board(int rows, int cols) {
        this.rows = rows;
        this.cols = cols;
        this.grid = new char[rows][cols];

        for (int r = 0; r < rows; r++)
            for (int c = 0; c < cols; c++)
                grid[r][c] = '.';
    }

    public boolean canPlace(boolean[][] shape, int r, int c) {
        for (int i = 0; i < shape.length; i++)
            for (int j = 0; j < shape[i].length; j++)
                if (shape[i][j]) {
                    int rr = r + i;
                    int cc = c + j;
                    if (rr < 0 || cc < 0 || rr >= rows || cc >= cols || grid[rr][cc] != '.')
                        return false;
                }
        return true;
    }

    public void place(boolean[][] shape, int r, int c, char name) {
        for (int i = 0; i < shape.length; i++)
            for (int j = 0; j < shape[i].length; j++)
                if (shape[i][j])
                    grid[r + i][c + j] = name;
    }

    public void remove(boolean[][] shape, int r, int c) {
        for (int i = 0; i < shape.length; i++)
            for (int j = 0; j < shape[i].length; j++)
                if (shape[i][j])
                    grid[r + i][c + j] = '.';
    }

    public String serialize() {
        StringBuilder sb = new StringBuilder();
        for (char[] row : grid) {
            sb.append(row).append('\n');
        }
        return sb.toString();
    }
}
5ï¸âƒ£ Solver â€“ Backtracking
ğŸ§  PentominoSolver.java
package solver;

import model.Board;
import model.Pentomino;

import java.util.List;

public class PentominoSolver {

    private int steps = 0;

    public boolean solve(Board board, List<Pentomino> pieces, int index) {
        if (index == pieces.size()) return true;

        Pentomino p = pieces.get(index);

        for (boolean[][] shape : p.getOrientations()) {
            for (int r = 0; r < 10; r++) {
                for (int c = 0; c < 10; c++) {
                    steps++;
                    if (board.canPlace(shape, r, c)) {
                        board.place(shape, r, c, p.getName());
                        if (solve(board, pieces, index + 1)) return true;
                        board.remove(shape, r, c);
                    }
                }
            }
        }
        return false;
    }

    public int getSteps() {
        return steps;
    }
}
6ï¸âƒ£ Persistencia â€“ Oracle 19c
ğŸ”Œ DBConnection.java
package util;

import java.sql.Connection;
import java.sql.DriverManager;

public class DBConnection {

    public static Connection getConnection() throws Exception {
        return DriverManager.getConnection(
            "jdbc:oracle:thin:@localhost:1521:ORCL",
            "USUARIO",
            "PASSWORD"
        );
    }
}
ğŸ’¾ GameResultDAO.java
package dao;

import util.DBConnection;

import java.sql.Connection;
import java.sql.PreparedStatement;

public class GameResultDAO {

    public void save(int rows, int cols, String solution, int steps, long timeMs) throws Exception {

        String sql = """
            INSERT INTO PENTOMINO_GAME
            (BOARD_ROWS, BOARD_COLS, SOLUTION_TEXT, STEPS, EXEC_TIME_MS)
            VALUES (?, ?, ?, ?, ?)
        """;

        try (Connection con = DBConnection.getConnection();
             PreparedStatement ps = con.prepareStatement(sql)) {

            ps.setInt(1, rows);
            ps.setInt(2, cols);
            ps.setString(3, solution);
            ps.setInt(4, steps);
            ps.setLong(5, timeMs);
            ps.executeUpdate();
        }
    }
}
7ï¸âƒ£ Main.java
import dao.GameResultDAO;
import model.Board;
import solver.PentominoSolver;

public class Main {

    public static void main(String[] args) throws Exception {

        Board board = new Board(6, 10);
        PentominoSolver solver = new PentominoSolver();

        long start = System.currentTimeMillis();
        boolean solved = solver.solve(board, PentominoFactory.createAll(), 0);
        long end = System.currentTimeMillis();

        if (solved) {
            System.out.println("âœ” SoluciÃ³n encontrada");
            System.out.println(board.serialize());

            new GameResultDAO().save(
                6, 10,
                board.serialize(),
                solver.getSteps(),
                end - start
            );
        } else {
            System.out.println("âŒ No hay soluciÃ³n");
        }
    }
}
8ï¸âƒ£ Extensiones posibles
Puedes ampliar fÃ¡cilmente esta soluciÃ³n para incluir:

âœ… Interfaz grÃ¡fica con Swing o JavaFX

âœ… Almacenamiento de todas las soluciones

âœ… Uso de Stored Procedures en Oracle

âœ… EstadÃ­sticas por pieza

âœ… MVC completo

âœ… VisualizaciÃ³n grÃ¡fica del tablero

ğŸ“Œ Resultado:
Una base sÃ³lida, extensible y acadÃ©micamente correcta para resolver PentominÃ³s con Java SE + Oracle 19c, separando claramente modelo, lÃ³gica y persistencia.
